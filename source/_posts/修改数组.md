---
title: 修改数组
date: 2020-11-24 21:12:09
tags:
---

来自蓝桥杯省赛的一个题目 
# 题目
给定一个长度为 N 的数组 A=[A1,A2,⋅⋅⋅AN]，数组中有可能有重复出现的整数。现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改 A2,A3,⋅⋅⋅,AN。当修改 Ai 时，小明会检查 Ai 是否在 A1∼Ai−1 中出现过。如果出现过，则小明会给 Ai 加上 1；如果新的 Ai 仍在之前出现过，小明会持续给 Ai 加 1，直到 Ai 没有在 A1∼Ai−1 中出现过。当 AN 也经过上述修改之后，显然 A 数组中就没有重复的整数了。现在给定初始的 A 数组，请你计算出最终的 A 数组。

# 思路
我的思路就只知道模拟，但是模拟肯定T了，按照y总的思路这个题目用到了并查集，
y总给我的感觉就是，知道某个算法是解决某一类问题，然后分析问题的时候看是否需要用到这个效果，比如并查集，找到当前节点的祖先，还可以压缩路径，我这里就是查找下一个空节点，那么就将其作为上一个非空节点的父亲，可以省下查找时间。

思路 用一个father[]数组，记录下一个空节点的位置，每次这个位置被占用直接指向下一个节点，即将下一个节点当作这个节点的父亲

# 代码
```
#include<bits/stdc++.h>
using namespace std;

const int N=1100010;
int fa[N];

int find(int x)
{
	if(x!=fa[x]) fa[x]=find(fa[x]);
	return fa[x];
}

int main(void)
{
	for(int i=0;i<N;i++) fa[i]=i;
	int n;
	cin >> n;
	for(int i=0;i<n;i++)
	{
		int x;
		cin >> x;
		x=find(x);
		cout << x << " " ;
		fa[x]=x+1;
	}
	return 0;
}
```
