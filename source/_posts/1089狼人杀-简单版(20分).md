---
title: 1089 狼人杀-简单版 (20分) 
date: 2020-10-28 09:55:25
tags:
---
1089 狼人杀-简单版 (20分)
=========



# 题目
1089 狼人杀-简单版（20 分）-PAT乙级真题
以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？

本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？

输入格式：
输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。

输出格式：
如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤k[k+1]<b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。

输入样例 1：
5
-2
+3
-4
+5
+4
输出样例 1：
1 4
输入样例 2：
6
+6
+3
+1
-5
-2
+4
输出样例 2（解不唯一）：
1 5
输入样例 3：
5
-2
-3
-4
-5
-1
输出样例 3：
No Solution

```c++
#include<bits/stdc++.h>
using namespace std;

int st[110],v[110],n;
vector<int> sh;

int main(void)
{
    cin >> n;
    for(int i=1;i<=n;i++)
        cin >> v[i];
    
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            memset(st,1,sizeof st);
            sh.clear();
            st[i]=st[j]=-1;
            for(int k=1;k<=n;k++)
                if(v[k]*st[abs(v[k])]<0)
                    sh.push_back(k);
            
            if(sh.size()!=2) 
                continue;
            if(st[sh[0]]*st[sh[1]]>0)
                continue;
            
            cout << i << " " << j << endl;
            return 0;
        }
    }
    cout << "No Solution" << endl;
    return 0;
}
```

# 总结

这个题目很多地方运用到了数字正负号属性，避免多次的使用`if else`导致代码凌乱，例`if(st[sh[0]]*st[sh[1]]>0)` 这一行 利用应该是一正一负相乘判结果是否正确。



今天又是被柳神吊打的一天，这个题目一开始我的思路没有太大的问题，但是如果不出意外的话，我应该是找到了我本身的缺点所在的地方了，写题没有良好的规章制度，想到哪写到哪，没有提前做好所有的预判，特别是在考虑边界问题的时候，总是出现忘了前面的思路或者出现突然又想到了一种情况，导致程序写不下去。最新任务：想出解决问题的办法，改变刷题路数。
