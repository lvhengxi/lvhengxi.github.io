---
title: 背包问题
date: 2020-11-12 20:53:22
tags:
---

背包问题是真的经典啊，但是难也是真的难，第一版的话先将01背包和完全背包写了，这两个背包是最基本的，而且确实很像，像到就只有2个字符不一样。

# 01背包
从n件物品中选，每件物品只能选一次，不超过背包大小的情况下，如何装入更多的东西

用闫氏dp法 从集合的角度来思考

因为背包体积和第i个物品，我们先不考虑优化，我们选择二维dp数组 dp[i][j]

那么dp[i][j]的意义是什么呢？ <font color="#dd0000">所有的只从前i件物品中选，且体积不超过j的所有方案的集合</font><br />

集合如何划分呢？ 划分依据  <font color="#dd0000">1.所有选择第i个物品的方案。2.所有不选择第i个物品的方案。</font><br />

``` c++
for(int i=1;i<=n;i++)
	for(int j=0;j<=m;j++)
		if(j>=w[i])  //w[]为第i件物品的体积  v[]为第i件物品的价值
			dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i];
		else 
			dp[i][j]=dp[i-1][j];
```

# 完全背包 
和01背包唯一不同的点在于完全背包可以选择第i件物品任意个，也就是说每个物品可以选无数次

老规矩 集合角度分析 但是将集合划分为选择k个第i件物品

``` c++
for(int i = 1 ; i<=n ;i++)
	for(int j = 0 ; j<=m ;j++)
		for(int k = 0 ; k*v[i]<=j ; k++)
			f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
```
这样就没有问题了 但是新的问题出现了 这个代码的时间复杂度高达O^3 直接T了 那我们就要进行优化(我也不会优化 全靠大佬的博客救我)

核心点出现了 敲黑板 
dp[i][j]=max(dp[i-1][j],dp[i-1][j-v]+w,dp[i-1][j-2*v]+2*w],···)
dp[i][j-v]=max(		dp[i-1][j-v],dp[i-1][j-2*v]+2*w]···）

会发现上面对齐的地方已经计算过一次了 再重复计算就是增加时间复杂度 违背了dp的准则

上面的式子经过优化得到     dp[i][j]=max(dp[i-1][j],dp[i][j-v]+w)


``` c++
for(int i = 1 ; i <=n ;i++)
	for(int j = 0 ; j <=m ;j++)
		f[i][j] = f[i-1][j];
		if((j-v[i]>=0)
			f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
```







