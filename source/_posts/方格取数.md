---
title: 方格取数
date: 2020-11-27 19:08:58
tags:
---
题目来自 acwing 1027 

题意就是一个人走一个N*N的矩阵，走两次，只能向右或者向下，可以取到的最大的数是多少 

走两次，很迷惑啊 这一波我大意了 没有闪 ，实际上走两次是错误的，反例 不能往后和上走 可能第一次取完了之后 第二次有些就取不到了 


# 解题思路

需要进行优化 2个人一起 两个人的坐标使用 i1 j1 i2 j2 分别表示横纵坐标 使用四维数组代表这个题的时间复杂度是n^4 还是比较高的 思维方式比较简单 循环遍历即可 但是这个题目可以进行优化 优化变成 三维dp

# 三维dp
使用一个k来表示走了多少步 然后每个人走的步数例如k1=i1+j1 那么j1=k1-i1 dp[k][i1][i2]就可以表示出2个人同时走了k步且两个人的坐标了 还有一个问题 那就是同时走 如果走到同一个方格怎么处理 走到同一个方格就只能加一次那个方格的数目 那么i1==i2的时候相当于 (i1=i2 && j1=j2) 特判一下即可

# 代码
```c++
#include<bits/stdc++.h>
using namespace std;

int mp[1000][1000],dp[100][100][100]; //k i1 i2

int main(void)
{
	int N;
	scanf("%d",&N);
	int r,w,num;
	while(scanf("%d %d %d",&r,&w,&num),r||w||num) mp[r][w]=num;

	//两个人一起走 只要不走到同一格就行 否则 同一格子只加一次

	for(int k=2;k<=2*N;k++)
	{
		for(int i1=1;i1<=N;i1++)
		{
			for(int i2=1;i2<=N;i2++)
			{
				int t=mp[i1][k-i1];
				if(i1!=i2) t+=mp[i2][k-i2];
				dp[k][i1][i2]=max(dp[k-1][i1-1][i2-1]+t,dp[k][i1][i2]);
				dp[k][i1][i2]=max(dp[k-1][i1-1][i2]+t,dp[k][i1][i2]);
				dp[k][i1][i2]=max(dp[k-1][i1][i2-1]+t,dp[k][i1][i2]);
				dp[k][i1][i2]=max(dp[k-1][i1][i2]+t,dp[k][i1][i2]);
			}
		}
	}
	cout << endl  << dp[2*N][N][N] << endl;
	return 0;
}
```
