---
title: 最长相同子序列
date: 2020-11-13 19:14:17
tags:
---
给字符串a,b，求出两者的最长相同子序列，我觉得这个题目记忆化搜索比较好，主要是我不知道这个题应该怎么进行dp 
想法就是 开一个数组dp[i][j]  然后每一次遇到相同的字符 就去查看上一个两者相同的字符也就是dp[i-1][j-1]如何有的话就+1 没有就直接为0即可 想法还是不算太难的

``` c++
#include<bits/stdc++.h>
using namespace std;

int dp[110][110],ans;

int main(void)
{
	string a,b;
	cin >> a >> b;
	for(int i=0;i<a.size();i++) 
		if(a[i]==b[0])
			dp[0][i]=1,ans=1;

	for(int i=0;i<b.size();i++)
		if(b[i]==a[0])
			dp[i][0]=1,ans=1;

	for(int i=1;i<=a.size();i++)
	{
		for(int j=1;j<=b.size();j++)
		{
			dp[i][j]=0;
			if(a[i]==b[j])
				dp[i][j]=dp[i-1][j-1]+1;

			ans=max(ans,dp[i][j]);
		}
	}
	cout << ans << endl;
	return 0;
}
```

# 奇怪的结论
学习这个最长共同子序列的主要原因是因为下面这个题目有个我不会证明的结论 但是如果使用这个结论就会很快解出答案

题目是蓝桥杯c++省赛A组的密码脱离

先说一个很重要的结论 

一个字符串需要添加多少个字符才可以变成回文串 等价于 一个字符串减去多少个字符变成回文串
一个字符串需要添加多少个字符才可以变成回文串 等价于 一个字符串减去多少个字符变成回文串
一个字符串需要添加多少个字符才可以变成回文串 等价于 一个字符串减去多少个字符变成回文串 

然后这个结论就很有意思了 

一个字符串和他的反串也就是经过reverse()之后的字符串对比 字符串的长度 减去 最长相同子序列的长度 等于 需要减去的字符 等于 需要加上的字符
