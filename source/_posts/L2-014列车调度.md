---
title: L2-014列车调度
date: 2020-11-19 14:01:24
tags:
---

很有趣的一道题目，想了很久的方案，有两种方案都很接近了，但是没有写出来

# 我的错误方案
1.只要下一个数大于前面轨道的末尾那个数字就重新开一组，然后最后统计，问题是开很多的队列很复杂 无法实现
2.开一个队列，每次都往里面输入，只要输入的数字比上一个数字大就答案+1 但是问题又来了进入的数字可能会开出，会空出一些轨道来，这样我如果再+1个答案就会出错
3.查看有多少个下降子序列 算出总数然后输出 其实是和第二种一样的 也是同样的问题

# 标准答案	
set容器的灵活运用，每次都将末尾的那个数字记录下来，如果输入进来的数比所有的末尾数都大 直接加入set容器 否则删除刚好比输入的数字大的那个末尾，然后再添加进去 相当于一次刷新末尾功能

感觉和汉诺塔问题很相似 

# 代码 
```c++
#include<bits/stdc++.h>
using namespace std;

set<int> q;

int main(void)
{
	q.insert(0);
	int n;
	cin >> n;
	for(int i=0;i<n;i++)
	{
		int temp;
		cin >> temp;
		if(temp<*q.rbegin())
			q.erase(*q.upper_bound(temp));
		q.insert(temp);
	}
	cout << q.size()-1 << endl;
	return 0;
}
```
